<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nebula Hand Control</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.4.1646424915/camera_utils.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.4.1646424915/drawing_utils.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #050505;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #video {
            display: none;
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .start-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 60px;
            font-size: 18px;
            font-weight: 600;
            color: #050505;
            background: linear-gradient(135deg, #00d9ff, #0099ff);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.5);
            transition: all 0.3s ease;
            pointer-events: all;
            z-index: 100;
        }

        .start-button:hover {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 50px rgba(0, 217, 255, 0.8);
        }

        .start-button.hidden {
            display: none;
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(5, 5, 5, 0.9);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 8px;
            padding: 15px 20px;
            font-size: 12px;
            color: #00d9ff;
            pointer-events: all;
            max-width: 280px;
            backdrop-filter: blur(10px);
        }

        .info-panel p {
            margin: 8px 0;
            line-height: 1.4;
        }

        .shape-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(5, 5, 5, 0.9);
            border: 2px solid rgba(0, 217, 255, 0.5);
            border-radius: 8px;
            padding: 15px 25px;
            font-size: 14px;
            color: #00d9ff;
            text-align: center;
            pointer-events: all;
            backdrop-filter: blur(10px);
            min-width: 150px;
        }

        .shape-name {
            font-weight: 600;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .hand-count {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(5, 5, 5, 0.9);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 12px;
            color: #00d9ff;
            pointer-events: all;
            backdrop-filter: blur(10px);
        }

        .copyright {
            position: absolute;
            bottom: 15px;
            right: 15px;
            font-size: 11px;
            color: rgba(0, 217, 255, 0.4);
            pointer-events: all;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <video id="video" width="640" height="480" playsinline></video>
    
    <div class="ui-overlay">
        <button class="start-button" id="startBtn">START NEBULA</button>
        <div class="hand-count" id="handCount">Hands: 0</div>
        <div class="shape-indicator" id="shapeIndicator">
            <div class="shape-name" id="shapeName">SPHERE</div>
        </div>
        <div class="info-panel">
            <p><strong>Controls:</strong></p>
            <p>üñêÔ∏è Hand position ‚Üí Rotate</p>
            <p>‚úåÔ∏è Pinch ‚Üí Attract/Repel</p>
            <p>üëã Swipe ‚Üí Change shape</p>
            <p>ü§ù Two hands ‚Üí Zoom</p>
        </div>
        <div class="copyright">¬© 2025 Muhammad Daler - Nebula Hand Control</div>
    </div>

    <script>
        // ==================== CONFIGURATION ====================
        const CONFIG = {
            particleCount: 15000,
            shapes: ['SPHERE', 'HEART', 'FLOWER', 'SATURN', 'FIREWORKS'],
            audioEnabled: false,
            handSmoothing: 0.15,
            particleLerpSpeed: 0.08,
        };

        // ==================== STATE ====================
        const state = {
            started: false,
            currentShapeIndex: 0,
            hands: [],
            audioContext: null,
            audioEngine: null,
        };

        // ==================== THREE.JS SETUP ====================
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x050505, 1);
        camera.position.z = 25;

        // ==================== PARTICLE SYSTEM ====================
        let particleGeometry;
        let particleMesh;
        let targetPositions = new Float32Array(CONFIG.particleCount * 3);
        let currentPositions = new Float32Array(CONFIG.particleCount * 3);

        function createParticleSystem() {
            if (particleMesh) scene.remove(particleMesh);

            particleGeometry = new THREE.BufferGeometry();
            const positions = generateSphereParticles(CONFIG.particleCount);
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const canvas = createParticleTexture();
            const texture = new THREE.CanvasTexture(canvas);

            const material = new THREE.PointsMaterial({
                size: 0.15,
                map: texture,
                transparent: true,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
            });

            particleMesh = new THREE.Points(particleGeometry, material);
            scene.add(particleMesh);

            currentPositions = positions.slice();
            targetPositions = positions.slice();
        }

        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(0, 217, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(0, 150, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 100, 255, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);

            return canvas;
        }

        function generateSphereParticles(count) {
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const radius = 8;

                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            return positions;
        }

        function generateHeartParticles(count) {
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                const scale = 4;

                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);

                positions[i * 3] = (x / 5) + (Math.random() - 0.5) * 0.5;
                positions[i * 3 + 1] = (y / 5) + (Math.random() - 0.5) * 0.5;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
            }
            return positions;
        }

        function generateFlowerParticles(count) {
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                const r = 8 * Math.sin(5 * t);
                const x = r * Math.cos(t);
                const y = r * Math.sin(t);

                positions[i * 3] = x + (Math.random() - 0.5) * 0.3;
                positions[i * 3 + 1] = y + (Math.random() - 0.5) * 0.3;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
            }
            return positions;
        }

        function generateSaturnParticles(count) {
            const positions = new Float32Array(count * 3);
            const coreCount = Math.floor(count * 0.6);
            const ringCount = count - coreCount;

            for (let i = 0; i < coreCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const radius = 4;

                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }

            for (let i = coreCount; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 1;

                positions[i * 3] = distance * Math.cos(theta);
                positions[i * 3 + 1] = (Math.random() - 0.5) * 1;
                positions[i * 3 + 2] = distance * Math.sin(theta);
            }
            return positions;
        }

        function generateFireworksParticles(count) {
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = Math.random() * 15;

                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            return positions;
        }

        function changeShape(index) {
            const shapeGenerators = [
                generateSphereParticles,
                generateHeartParticles,
                generateFlowerParticles,
                generateSaturnParticles,
                generateFireworksParticles,
            ];

            targetPositions = shapeGenerators[index](CONFIG.particleCount);
            document.getElementById('shapeName').textContent = CONFIG.shapes[index];

            if (state.audioEngine) {
                state.audioEngine.playSFX();
            }
        }

        // ==================== AUDIO ENGINE ====================
        class AudioEngine {
            constructor(audioContext) {
                this.ctx = audioContext;
                this.droneOscillator = null;
                this.droneLowPass = null;
                this.droneGain = null;
                this.isPlaying = false;
            }

            start() {
                if (this.isPlaying) return;
                this.isPlaying = true;

                this.droneOscillator = this.ctx.createOscillator();
                this.droneOscillator.type = 'sine';
                this.droneOscillator.frequency.value = 55;

                this.droneLowPass = this.ctx.createBiquadFilter();
                this.droneLowPass.type = 'lowpass';
                this.droneLowPass.frequency.value = 2000;
                this.droneLowPass.Q.value = 2;

                this.droneGain = this.ctx.createGain();
                this.droneGain.gain.value = 0.1;

                this.droneOscillator.connect(this.droneLowPass);
                this.droneLowPass.connect(this.droneGain);
                this.droneGain.connect(this.ctx.destination);

                this.droneOscillator.start();
            }

            updatePinch(pinchDistance) {
                if (!this.isPlaying) return;

                const freq = 55 + pinchDistance * 500;
                const cutoff = 800 + pinchDistance * 1500;
                const volume = Math.max(0.05, 0.3 - pinchDistance * 0.2);

                this.droneOscillator.frequency.setValueAtTime(freq, this.ctx.currentTime);
                this.droneLowPass.frequency.setValueAtTime(cutoff, this.ctx.currentTime);
                this.droneGain.gain.setValueAtTime(volume, this.ctx.currentTime);
            }

            playSFX() {
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.3, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < buffer.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                noise.buffer = buffer;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(5000, this.ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(500, this.ctx.currentTime + 0.3);

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                noise.start();
            }

            stop() {
                if (this.droneOscillator) {
                    this.droneOscillator.stop();
                    this.isPlaying = false;
                }
            }
        }

        // ==================== MEDIAPIPE SETUP ====================
        const videoElement = document.getElementById('video');
        const canvasElement = canvas;
        let mediaStreamCreated = false;

        async function initMediaPipe() {
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                },
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5,
            });

            hands.onResults((results) => {
                state.hands = results.multiHandLandmarks || [];
                document.getElementById('handCount').textContent = `Hands: ${state.hands.length}`;
            });

            if (!mediaStreamCreated) {
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 640,
                    height: 480,
                });
                await camera.initialize();
                await camera.start();
                mediaStreamCreated = true;
            }
        }

        // ==================== HAND INTERACTION ====================
        const handState = {
            left: { position: null, pinchDistance: 0, lastSwipeX: 0 },
            right: { position: null, pinchDistance: 0, lastSwipeX: 0 },
        };

        function processHands() {
            if (state.hands.length === 0) return;

            if (state.hands.length >= 1) {
                const landmarks = state.hands[0];
                const indexFinger = landmarks[8];
                const thumb = landmarks[4];
                const middleFinger = landmarks[12];

                const pinchDist = Math.hypot(
                    indexFinger.x - thumb.x,
                    indexFinger.y - thumb.y
                );

                handState.left.pinchDistance = pinchDist;
                handState.left.position = indexFinger;

                if (Math.abs(indexFinger.x - handState.left.lastSwipeX) > 0.15) {
                    if (indexFinger.x > handState.left.lastSwipeX) {
                        state.currentShapeIndex = (state.currentShapeIndex + 1) % CONFIG.shapes.length;
                        changeShape(state.currentShapeIndex);
                    }
                    handState.left.lastSwipeX = indexFinger.x;
                }
            }

            if (state.hands.length >= 2) {
                const leftIndexFinger = state.hands[0][8];
                const rightIndexFinger = state.hands[1][8];

                const zoomDistance = Math.hypot(
                    rightIndexFinger.x - leftIndexFinger.x,
                    rightIndexFinger.y - leftIndexFinger.y
                );

                const scale = 0.5 + zoomDistance * 2.5;
                camera.scale.set(scale, scale, scale);
            } else {
                camera.scale.set(1, 1, 1);
            }
        }

        function attractRepelParticles(handIndex) {
            if (!state.hands[handIndex]) return;

            const landmarks = state.hands[handIndex];
            const indexFinger = landmarks[8];
            const pinchDistance = Math.hypot(
                indexFinger.x - landmarks[4].x,
                indexFinger.y - landmarks[4].y
            );

            const handWorldX = (indexFinger.x - 0.5) * 40;
            const handWorldY = (0.5 - indexFinger.y) * 30;
            const handWorldZ = 0;

            const attractThreshold = 0.2;
            const attractRadius = 15;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const idx = i * 3;
                const px = currentPositions[idx];
                const py = currentPositions[idx + 1];
                const pz = currentPositions[idx + 2];

                const dx = px - handWorldX;
                const dy = py - handWorldY;
                const dz = pz - handWorldZ;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < attractRadius) {
                    if (pinchDistance < attractThreshold) {
                        const force = (1 - dist / attractRadius) * 0.5;
                        targetPositions[idx] = px - (dx / dist) * force;
                        targetPositions[idx + 1] = py - (dy / dist) * force;
                        targetPositions[idx + 2] = pz - (dz / dist) * force;
                    } else {
                        const force = (1 - dist / attractRadius) * 0.3;
                        targetPositions[idx] = px + (dx / dist) * force;
                        targetPositions[idx + 1] = py + (dy / dist) * force;
                        targetPositions[idx + 2] = pz + (dz / dist) * force;
                    }
                }
            }

            if (state.audioEngine) {
                state.audioEngine.updatePinch(pinchDistance);
            }
        }

        function rotateSceneByHand() {
            if (!state.hands[0]) return;

            const indexFinger = state.hands[0][8];
            const rotX = (indexFinger.y - 0.5) * Math.PI * 0.5;
            const rotY = (indexFinger.x - 0.5) * Math.PI * 0.5;

            particleMesh.rotation.x += (rotX - particleMesh.rotation.x) * 0.1;
            particleMesh.rotation.y += (rotY - particleMesh.rotation.y) * 0.1;
        }

        // ==================== ANIMATION LOOP ====================
        function animate() {
            requestAnimationFrame(animate);

            if (!state.started) {
                renderer.render(scene, camera);
                return;
            }

            processHands();
            rotateSceneByHand();

            for (let i = 0; i < state.hands.length; i++) {
                attractRepelParticles(i);
            }

            // Lerp particles to target positions
            const positions = particleGeometry.attributes.position.array;
            for (let i = 0; i < CONFIG.particleCount * 3; i++) {
                currentPositions[i] += (targetPositions[i] - currentPositions[i]) * CONFIG.particleLerpSpeed;
                positions[i] = currentPositions[i];
            }
            particleGeometry.attributes.position.needsUpdate = true;

            // Color animation
            particleMesh.rotation.z += 0.001;

            renderer.render(scene, camera);
        }

        // ==================== UI EVENT LISTENERS ====================
        document.getElementById('startBtn').addEventListener('click', async () => {
            state.started = true;

            if (!state.audioContext) {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                state.audioEngine = new AudioEngine(state.audioContext);
                state.audioEngine.start();
            }

            document.getElementById('startBtn').classList.add('hidden');

            await initMediaPipe();
        });

        // ==================== WINDOW RESIZE ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== INITIALIZATION ====================
        createParticleSystem();
        animate();
    </script>
</body>
</html>
