<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nur & Ilm Hand Control</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&family=Inter:wght@300;400;500&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #050505;
            font-family: 'Inter', sans-serif;
            color: rgba(255, 255, 255, 0.9);
        }
        
        canvas {
            display: block;
        }
        
        .ar-text {
            font-family: 'Amiri', serif;
            font-size: 2.5rem;
            line-height: 1.6;
            text-align: center;
        }
        
        .overlay-text {
            background: linear-gradient(180deg, rgba(5,5,5,0.9) 0%, transparent 100%);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .breath-animation {
            animation: breath 8s ease-in-out infinite;
        }
        
        @keyframes breath {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .gold-gradient {
            background: linear-gradient(135deg, #D4AF37 0%, #FFD700 50%, #B8860B 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .emerald-gradient {
            background: linear-gradient(135deg, #50C878 0%, #0BDA51 50%, #00693E 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .particle-glow {
            filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.3));
        }
    </style>
</head>
<body class="bg-[#050505]">
    <!-- Hidden video for MediaPipe -->
    <video id="video-input" style="display: none; position: absolute; width: 640px; height: 480px;"></video>
    
    <!-- Canvas for Three.js -->
    <canvas id="scene-canvas"></canvas>
    
    <!-- Overlay UI -->
    <div class="absolute inset-0 pointer-events-none">
        <!-- Ayah Display -->
        <div id="ayah-container" class="absolute top-4 left-1/2 transform -translate-x-1/2 w-full max-w-4xl px-4 overlay-text breath-animation hidden">
            <div class="ar-text gold-gradient mb-2" id="arabic-text"></div>
            <div class="text-sm opacity-80 text-center mb-6" id="translation-text"></div>
        </div>
        
        <!-- Wisdom Text -->
        <div id="wisdom-container" class="absolute bottom-20 left-1/2 transform -translate-x-1/2 w-full max-w-2xl px-4 text-center hidden">
            <div class="text-lg emerald-gradient mb-1" id="wisdom-text"></div>
            <div class="text-xs opacity-70" id="wisdom-source"></div>
        </div>
        
        <!-- Scientific Insight -->
        <div id="science-container" class="absolute bottom-8 left-1/2 transform -translate-x-1/2 w-full max-w-2xl px-4 text-center hidden">
            <div class="text-sm text-blue-300" id="science-text"></div>
        </div>
        
        <!-- Start Button -->
        <div id="start-container" class="absolute inset-0 flex items-center justify-center bg-[#050505] transition-opacity duration-1000">
            <div class="text-center">
                <div class="mb-8">
                    <div class="text-4xl gold-gradient mb-2">Nur & Ilm</div>
                    <div class="text-lg opacity-80">Hand Control</div>
                </div>
                <button id="start-button" 
                        class="pointer-events-auto px-8 py-3 bg-gradient-to-r from-[#D4AF37] to-[#B8860B] text-black rounded-lg text-lg font-medium hover:opacity-90 transition-opacity">
                    Boshlash
                </button>
                <div class="mt-4 text-sm opacity-60 max-w-md">
                    Ilohiy oyatlarni qo'l harakatlaringiz orqali kashf eting.<br>
                    Kamera ruxsati kerak. Hech qanday video serverga yuborilmaydi.
                </div>
            </div>
        </div>
        
        <!-- Status -->
        <div class="absolute top-4 right-4 text-xs opacity-60">
            <div>15,000 nuriy zarrachalar</div>
            <div id="fps-counter">60 FPS</div>
        </div>
        
        <!-- Instructions -->
        <div class="absolute bottom-4 left-4 text-xs opacity-50 max-w-xs">
            <div class="mb-1">ğŸ‘† Bitta qo'l: aylantirish</div>
            <div class="mb-1">âœŒï¸ Ikkita qo'l: chuqurlik</div>
            <div>ğŸ‘Œ Pinch: birlik / tarqalish</div>
        </div>
    </div>

    <script>
        // ==================== TYPES & DATA ====================
        const ParticleShape = {
            NurSphere: 0,
            AyahHalo: 1,
            KnowledgeSpiral: 2,
            CosmicExpansion: 3,
            QalbField: 4
        };

        const AYAH_DATA = [
            {
                arabic: "Ù±Ù„Ù„Ù‘ÙÙ‡Ù Ù†ÙÙˆØ±Ù Ù±Ù„Ø³Ù‘ÙÙ…ÙÙ€Ù°ÙˆÙÙ°ØªÙ ÙˆÙÙ±Ù„Ù’Ø£ÙØ±Ù’Ø¶Ù Ûš Ù…ÙØ«ÙÙ„Ù Ù†ÙÙˆØ±ÙÙ‡ÙÛ¦ ÙƒÙÙ…ÙØ´Ù’ÙƒÙÙˆÙ°Ø©Ù ÙÙÙŠÙ‡ÙØ§ Ù…ÙØµÙ’Ø¨ÙØ§Ø­ÙŒ Û– Ù±Ù„Ù’Ù…ÙØµÙ’Ø¨ÙØ§Ø­Ù ÙÙÙ‰ Ø²ÙØ¬ÙØ§Ø¬ÙØ©Ù Û– Ù±Ù„Ø²Ù‘ÙØ¬ÙØ§Ø¬ÙØ©Ù ÙƒÙØ£ÙÙ†Ù‘ÙÙ‡ÙØ§ ÙƒÙÙˆÙ’ÙƒÙØ¨ÙŒ Ø¯ÙØ±Ù‘ÙÙ‰Ù‘ÙŒ",
                translation: "Alloh osmonlar va Yerning nuridir. Uning nurining misoli bir mushkobda boÊ»lgan chiroqqa oÊ»xshaydi. U chiroq shishada, shisha esa marvaridga oÊ»xshash yulduzdek.",
                wisdom: "Nur mohiyati mushkobda yashiringan chiroqdek â€” u bor, lekin bevosita koÊ»rinmaydi",
                source: "Ibn Sina â€” Ilm hikmati",
                science: "Har bir nur nuriyasi subatomik darajada kvant maydonlarining tebranishidir"
            },
            {
                arabic: "Ù±Ù‚Ù’Ø±ÙØ£Ù’ Ø¨ÙÙ±Ø³Ù’Ù…Ù Ø±ÙØ¨Ù‘ÙÙƒÙ Ù±Ù„Ù‘ÙØ°ÙÙ‰ Ø®ÙÙ„ÙÙ‚Ù * Ø®ÙÙ„ÙÙ‚Ù Ù±Ù„Ù’Ø¥ÙÙ†Ø³ÙÙ€Ù°Ù†Ù Ù…ÙÙ†Ù’ Ø¹ÙÙ„ÙÙ‚Ù * Ù±Ù‚Ù’Ø±ÙØ£Ù’ ÙˆÙØ±ÙØ¨Ù‘ÙÙƒÙ Ù±Ù„Ù’Ø£ÙÙƒÙ’Ø±ÙÙ…Ù * Ù±Ù„Ù‘ÙØ°ÙÙ‰ Ø¹ÙÙ„Ù‘ÙÙ…Ù Ø¨ÙÙ±Ù„Ù’Ù‚ÙÙ„ÙÙ…Ù",
                translation: "Yaratgan Rabbingning nomi bilan oÊ»qi! U insonni alaqadan yaratdi. OÊ»qi, chunki Rabbing eng saxiydir. U qalam bilan oÊ»rgatdi.",
                wisdom: "Birinchi vahiy 'oÊ»qish' bilan boshlanadi â€” bu ilmdan o'zib ketish emas, balki ma'rifatga yo'l",
                source: "Al-Farabi â€” Ilm hikmati",
                science: "Inson miyasining neyroplastikligi â€” oÊ»qish va oÊ»rganish orqali miya tuzilishi oÊ»zgaradi"
            },
            {
                arabic: "Ø£ÙÙÙÙ„ÙØ§ ÙŠÙÙ†Ø¸ÙØ±ÙÙˆÙ†Ù Ø¥ÙÙ„ÙÙ‰ Ù±Ù„Ù’Ø¥ÙØ¨ÙÙ„Ù ÙƒÙÙŠÙ’ÙÙ Ø®ÙÙ„ÙÙ‚ÙØªÙ’ * ÙˆÙØ¥ÙÙ„ÙÙ‰ Ù±Ù„Ø³Ù‘ÙÙ…ÙØ¢Ø¡Ù ÙƒÙÙŠÙ’ÙÙ Ø±ÙÙÙØ¹ÙØªÙ’ * ÙˆÙØ¥ÙÙ„ÙÙ‰ Ù±Ù„Ù’Ø¬ÙØ¨ÙØ§Ù„Ù ÙƒÙÙŠÙ’ÙÙ Ù†ÙØµÙØ¨ÙØªÙ’ * ÙˆÙØ¥ÙÙ„ÙÙ‰ Ù±Ù„Ù’Ø£ÙØ±Ù’Ø¶Ù ÙƒÙÙŠÙ’ÙÙ Ø³ÙØ·ÙØ­ÙØªÙ’",
                translation: "Ular tuyaga qaramaydilarmikin, qanday yaratilganiga? Osmonga qaramaydilarmikin, qanday koÊ»tarilganiga? TogÊ»larga qaramaydilarmikin, qanday qoÊ»yilganiga? Yerga qaramaydilarmikin, qanday yoyilganiga?",
                wisdom: "Har bir mahluk o'zida Koinotning sirli yozuvini saqlaydi",
                source: "Al-Biruni â€” Ilm hikmati",
                science: "Yer yuzasining tekislanishi tektonik plitalar harakatining milyon yillik natijasidir"
            }
        ];

        const WISDOM_DATA = [
            "Aql â€” bu nur, qalb esa uning uyi. Ikkalasi muvozanatda boÊ»lsa, haqiqat yorqin koÊ»rinadi",
            "Koinotning har bir nuqtasi Butunning xabarchisidir",
            "Vaqt â€” bu mavjudotning nafasi, har bir daqiqa yangi imkoniyat",
            "Ilm â€” bu qalbni Allohga olib boradigan nuriy yoÊ»l"
        ];

        // ==================== UTILITIES ====================
        class ShapesGenerator {
            static generateSphere(particleCount) {
                const positions = new Float32Array(particleCount * 3);
                const radius = 3;
                
                for (let i = 0; i < particleCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = radius * Math.cbrt(Math.random());
                    
                    const idx = i * 3;
                    positions[idx] = r * Math.sin(phi) * Math.cos(theta);
                    positions[idx + 1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[idx + 2] = r * Math.cos(phi);
                }
                
                return positions;
            }
            
            static generateHalo(particleCount) {
                const positions = new Float32Array(particleCount * 3);
                const radius = 4;
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const r = radius + Math.sin(angle * 5) * 0.5;
                    
                    const idx = i * 3;
                    positions[idx] = Math.cos(angle) * r;
                    positions[idx + 1] = Math.sin(angle) * r;
                    positions[idx + 2] = Math.sin(angle * 3) * 0.5;
                }
                
                return positions;
            }
            
            static generateSpiral(particleCount) {
                const positions = new Float32Array(particleCount * 3);
                const turns = 8;
                
                for (let i = 0; i < particleCount; i++) {
                    const t = i / particleCount;
                    const angle = t * Math.PI * 2 * turns;
                    const radius = t * 3;
                    const height = (t - 0.5) * 8;
                    
                    const idx = i * 3;
                    positions[idx] = Math.cos(angle) * radius;
                    positions[idx + 1] = height;
                    positions[idx + 2] = Math.sin(angle) * radius;
                }
                
                return positions;
            }
            
            static generateExpansion(particleCount) {
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.pow(Math.random(), 0.3) * 6;
                    
                    const idx = i * 3;
                    positions[idx] = r * Math.sin(phi) * Math.cos(theta);
                    positions[idx + 1] = r * Math.sin(phi) * Math.sin(theta) * 0.3;
                    positions[idx + 2] = r * Math.cos(phi);
                }
                
                return positions;
            }
            
            static generateHeartField(particleCount) {
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const t = Math.random() * Math.PI * 2;
                    const scale = 2 + Math.random() * 2;
                    
                    const x = scale * 16 * Math.pow(Math.sin(t), 3);
                    const y = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    const z = (Math.random() - 0.5) * 3;
                    
                    const idx = i * 3;
                    positions[idx] = x * 0.1;
                    positions[idx + 1] = y * 0.1;
                    positions[idx + 2] = z;
                }
                
                return positions;
            }
            
            static getShapePositions(shape, particleCount) {
                switch(shape) {
                    case ParticleShape.NurSphere:
                        return this.generateSphere(particleCount);
                    case ParticleShape.AyahHalo:
                        return this.generateHalo(particleCount);
                    case ParticleShape.KnowledgeSpiral:
                        return this.generateSpiral(particleCount);
                    case ParticleShape.CosmicExpansion:
                        return this.generateExpansion(particleCount);
                    case ParticleShape.QalbField:
                        return this.generateHeartField(particleCount);
                    default:
                        return this.generateSphere(particleCount);
                }
            }
        }

        class AudioEngine {
            constructor() {
                this.audioContext = null;
                this.gainNode = null;
                this.oscillator = null;
                this.noiseNode = null;
                this.isPlaying = false;
            }
            
            init() {
                if (this.audioContext) return;
                
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.gainNode = this.audioContext.createGain();
                this.gainNode.gain.value = 0.1;
                this.gainNode.connect(this.audioContext.destination);
                
                // Create calm hum
                this.oscillator = this.audioContext.createOscillator();
                this.oscillator.type = 'sine';
                this.oscillator.frequency.value = 55; // Low frequency for calmness
                this.oscillator.connect(this.gainNode);
                
                // Create breath-like noise
                this.noiseNode = this.audioContext.createBufferSource();
                const bufferSize = this.audioContext.sampleRate * 2;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                this.noiseNode.buffer = buffer;
                this.noiseNode.loop = true;
                
                const noiseFilter = this.audioContext.createBiquadFilter();
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = 200;
                noiseFilter.Q.value = 0.5;
                
                const noiseGain = this.audioContext.createGain();
                noiseGain.gain.value = 0.02;
                
                this.noiseNode.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.gainNode);
            }
            
            start() {
                if (!this.audioContext || this.isPlaying) return;
                
                this.init();
                this.oscillator.start();
                this.noiseNode.start();
                this.isPlaying = true;
            }
            
            updateFromHands(handData) {
                if (!this.isPlaying || !this.audioContext) return;
                
                const calmness = 1 - (handData.speed || 0);
                const targetGain = 0.05 + calmness * 0.1;
                const targetFreq = 55 + (1 - calmness) * 20;
                
                this.gainNode.gain.linearRampToValueAtTime(
                    targetGain,
                    this.audioContext.currentTime + 0.1
                );
                
                this.oscillator.frequency.linearRampToValueAtTime(
                    targetFreq,
                    this.audioContext.currentTime + 0.1
                );
            }
            
            playSwipeEffect() {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.5);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.5);
            }
        }

        // ==================== MAIN APPLICATION ====================
        class NurIlmApp {
            constructor() {
                this.particleCount = 15000;
                this.currentShape = ParticleShape.NurSphere;
                this.targetShape = ParticleShape.NurSphere;
                this.morphProgress = 0;
                this.morphSpeed = 0.02;
                
                this.hands = null;
                this.lastHandsTime = 0;
                this.handData = {
                    left: null,
                    right: null,
                    pinchStrength: 0,
                    speed: 0
                };
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.particles = null;
                this.positions = null;
                this.targetPositions = null;
                
                this.currentAyahIndex = 0;
                this.textDisplayTime = 0;
                this.textCycleInterval = 15000; // 15 seconds
                
                this.audioEngine = new AudioEngine();
                this.lastFrameTime = 0;
                this.fps = 60;
                
                this.isStarted = false;
                
                this.init();
            }
            
            init() {
                this.initThreeJS();
                this.initMediaPipe();
                this.initEventListeners();
                this.updateUI();
                this.animate();
            }
            
            initThreeJS() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050505);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 15;
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('scene-canvas'),
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(0x000000, 1);
                
                // Particles
                this.createParticles();
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xD4AF37, 0.5);
                directionalLight.position.set(5, 5, 5);
                this.scene.add(directionalLight);
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            createParticles() {
                const geometry = new THREE.BufferGeometry();
                
                // Initial positions
                this.positions = ShapesGenerator.getShapePositions(this.currentShape, this.particleCount);
                geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                
                // Colors
                const colors = new Float32Array(this.particleCount * 3);
                for (let i = 0; i < this.particleCount; i++) {
                    const idx = i * 3;
                    colors[idx] = 0.85;     // R
                    colors[idx + 1] = 0.75; // G
                    colors[idx + 2] = 0.3;  // B
                }
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                // Material
                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
                
                // Create target positions
                this.targetPositions = new Float32Array(this.particleCount * 3);
                this.updateTargetPositions();
            }
            
            updateTargetPositions() {
                const newPositions = ShapesGenerator.getShapePositions(this.targetShape, this.particleCount);
                this.targetPositions.set(newPositions);
            }
            
            initMediaPipe() {
                const videoElement = document.getElementById('video-input');
                
                this.hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                this.hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                this.hands.onResults((results) => this.onHandResults(results));
                
                // Start camera
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await this.hands.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
            }
            
            onHandResults(results) {
                const now = Date.now();
                const timeDiff = now - this.lastHandsTime;
                this.lastHandsTime = now;
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    this.processHandLandmarks(results.multiHandLandmarks, timeDiff);
                } else {
                    this.handData.left = null;
                    this.handData.right = null;
                    this.handData.pinchStrength = 0;
                    this.handData.speed = 0;
                }
                
                // Update audio based on hand movement
                this.audioEngine.updateFromHands(this.handData);
            }
            
            processHandLandmarks(landmarks, timeDiff) {
                let leftHand = null;
                let rightHand = null;
                
                // Separate left and right hands
                landmarks.forEach((hand, index) => {
                    if (hand.length >= 21) {
                        if (index === 0) {
                            leftHand = hand;
                        } else {
                            rightHand = hand;
                        }
                    }
                });
                
                this.handData.left = leftHand;
                this.handData.right = rightHand;
                
                // Calculate pinch strength from first hand
                if (leftHand || rightHand) {
                    const hand = leftHand || rightHand;
                    const thumbTip = hand[4];
                    const indexTip = hand[8];
                    
                    const dx = thumbTip.x - indexTip.x;
                    const dy = thumbTip.y - indexTip.y;
                    const dz = thumbTip.z - indexTip.z;
                    
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    this.handData.pinchStrength = 1 - Math.min(distance * 5, 1);
                    
                    // Calculate speed based on index finger movement
                    if (this.lastIndexPosition) {
                        const movement = Math.sqrt(
                            Math.pow(hand[8].x - this.lastIndexPosition.x, 2) +
                            Math.pow(hand[8].y - this.lastIndexPosition.y, 2)
                        );
                        this.handData.speed = movement / (timeDiff || 1) * 1000;
                    }
                    
                    this.lastIndexPosition = hand[8];
                }
                
                // Detect swipe for shape change
                this.detectSwipe();
            }
            
            detectSwipe() {
                if (!this.handData.left && !this.handData.right) return;
                
                const hand = this.handData.left || this.handData.right;
                const indexTip = hand[8];
                
                if (!this.lastSwipePosition) {
                    this.lastSwipePosition = {x: indexTip.x, y: indexTip.y, time: Date.now()};
                    return;
                }
                
                const dx = indexTip.x - this.lastSwipePosition.x;
                const dt = Date.now() - this.lastSwipePosition.time;
                
                // Swipe detected if fast horizontal movement
                if (dt > 100 && dt < 500 && Math.abs(dx) > 0.3) {
                    this.nextShape();
                    this.lastSwipePosition = null;
                    this.audioEngine.playSwipeEffect();
                    return;
                }
                
                // Update position every 100ms
                if (dt > 100) {
                    this.lastSwipePosition = {x: indexTip.x, y: indexTip.y, time: Date.now()};
                }
            }
            
            nextShape() {
                this.targetShape = (this.targetShape + 1) % 5;
                this.updateTargetPositions();
                this.morphProgress = 0;
                
                // Update ayah display
                this.currentAyahIndex = (this.currentAyahIndex + 1) % AYAH_DATA.length;
                this.updateUI();
            }
            
            initEventListeners() {
                document.getElementById('start-button').addEventListener('click', () => {
                    this.startExperience();
                });
            }
            
            startExperience() {
                this.isStarted = true;
                document.getElementById('start-container').style.opacity = '0';
                document.getElementById('start-container').style.pointerEvents = 'none';
                
                // Show ayah container
                document.getElementById('ayah-container').classList.remove('hidden');
                document.getElementById('wisdom-container').classList.remove('hidden');
                document.getElementById('science-container').classList.remove('hidden');
                
                // Start audio
                this.audioEngine.start();
                
                // Initial UI update
                this.updateUI();
                
                // Hide start container after transition
                setTimeout(() => {
                    document.getElementById('start-container').style.display = 'none';
                }, 1000);
            }
            
            updateUI() {
                if (!this.isStarted) return;
                
                const ayahData = AYAH_DATA[this.currentAyahIndex];
                
                // Update Arabic text
                document.getElementById('arabic-text').textContent = ayahData.arabic;
                document.getElementById('translation-text').textContent = ayahData.translation;
                document.getElementById('wisdom-text').textContent = ayahData.wisdom;
                document.getElementById('wisdom-source').textContent = ayahData.source;
                document.getElementById('science-text').textContent = ayahData.science;
                
                // Reset text timer
                this.textDisplayTime = Date.now();
            }
            
            updateParticles() {
                const positions = this.particles.geometry.attributes.position.array;
                
                // Morph towards target shape
                if (this.morphProgress < 1) {
                    this.morphProgress += this.morphSpeed;
                    
                    for (let i = 0; i < this.particleCount * 3; i++) {
                        positions[i] += (this.targetPositions[i] - positions[i]) * this.morphSpeed;
                    }
                    
                    this.particles.geometry.attributes.position.needsUpdate = true;
                }
                
                // Apply hand interactions
                if (this.handData.pinchStrength > 0.1) {
                    this.applyHandPhysics(positions);
                }
                
                // Rotate scene based on hand position
                if (this.handData.left || this.handData.right) {
                    const hand = this.handData.left || this.handData.right;
                    const wrist = hand[0];
                    
                    this.scene.rotation.x = (wrist.y - 0.5) * 0.5;
                    this.scene.rotation.y = (wrist.x - 0.5) * 0.5;
                }
                
                // Update colors based on pinch
                const colors = this.particles.geometry.attributes.color.array;
                const pinch = this.handData.pinchStrength;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const idx = i * 3;
                    colors[idx] = 0.85 + pinch * 0.15;     // R
                    colors[idx + 1] = 0.75 + pinch * 0.1; // G
                    colors[idx + 2] = 0.3 - pinch * 0.1;  // B
                }
                
                this.particles.geometry.attributes.color.needsUpdate = true;
            }
            
            applyHandPhysics(positions) {
                const pinch = this.handData.pinchStrength;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const idx = i * 3;
                    const x = positions[idx];
                    const y = positions[idx + 1];
                    const z = positions[idx + 2];
                    
                    const distance = Math.sqrt(x*x + y*y + z*z);
                    
                    if (pinch > 0.5) {
                        // Attract towards center (Tawhid)
                        const force = 0.005 * pinch;
                        positions[idx] -= x * force;
                        positions[idx + 1] -= y * force;
                        positions[idx + 2] -= z * force;
                    } else {
                        // Gentle repulsion (Expansion)
                        const force = 0.002 * (1 - pinch);
                        positions[idx] += x * force / (distance + 0.1);
                        positions[idx + 1] += y * force / (distance + 0.1);
                        positions[idx + 2] += z * force / (distance + 0.1);
                    }
                }
                
                this.particles.geometry.attributes.position.needsUpdate = true;
            }
            
            animate(currentTime = 0) {
                requestAnimationFrame((time) => this.animate(time));
                
                // Calculate FPS
                const delta = currentTime - this.lastFrameTime;
                this.lastFrameTime = currentTime;
                this.fps = Math.round(1000 / delta);
                
                // Update FPS display
                document.getElementById('fps-counter').textContent = `${Math.min(this.fps, 60)} FPS`;
                
                // Update particles
                if (this.particles) {
                    this.updateParticles();
                }
                
                // Auto-cycle text after interval
                if (this.isStarted && Date.now() - this.textDisplayTime > this.textCycleInterval) {
                    this.nextShape();
                }
                
                // Render
                if (this.renderer && this.scene && this.camera) {
                    this.renderer.render(this.scene, this.camera);
                }
            }
        }

        // ==================== INITIALIZATION ====================
        // Wait for page to load
        window.addEventListener('load', () => {
            // Initialize app
            window.app = new NurIlmApp();
            
            // Add touch prevention for mobile
            document.addEventListener('touchmove', (e) => {
                if (e.scale !== 1) {
                    e.preventDefault();
                }
            }, { passive: false });
        });

        // Polyfill for requestAnimationFrame
        (function() {
            var lastTime = 0;
            var vendors = ['ms', 'moz', 'webkit', 'o'];
            for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
                window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
                                           || window[vendors[x]+'CancelRequestAnimationFrame'];
            }
            
            if (!window.requestAnimationFrame)
                window.requestAnimationFrame = function(callback, element) {
                    var currTime = new Date().getTime();
                    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                    var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
                      timeToCall);
                    lastTime = currTime + timeToCall;
                    return id;
                };
            
            if (!window.cancelAnimationFrame)
                window.cancelAnimationFrame = function(id) {
                    clearTimeout(id);
                };
        }());
    </script>
</body>
</html>